#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import { execSync } from "node:child_process";

function run(cmd) { execSync(cmd, { stdio: "inherit" }); }
function read(p) { return fs.readFileSync(p, "utf8"); }
function write(p, s) { fs.writeFileSync(p, s); }
function exists(p) { return fs.existsSync(p); }

const ROOT = execSync("git rev-parse --show-toplevel", { encoding: "utf8" }).trim();
const CONTRACTS_DIR = path.join(ROOT, "packages/sentinel-core/src/contracts");
const BARREL = path.join(CONTRACTS_DIR, "index.ts");

const FILES = [
  { rel: "./executor.js", ts: path.join(CONTRACTS_DIR, "executor.ts") },
  { rel: "./registry.js", ts: path.join(CONTRACTS_DIR, "registry.ts") },
  { rel: "./plugin.js", ts: path.join(CONTRACTS_DIR, "plugin.ts") },
];

for (const f of FILES) {
  if (!exists(f.ts)) {
    throw new Error(`Missing expected contracts file: ${f.ts}`);
  }
}

function extractExports(tsSrc) {
  // We intentionally ignore re-exports and "export *" lines.
  // We capture simple "export <kind> Name" declarations.
  const types = new Set();
  const values = new Set();

  // export type Foo = ...
  for (const m of tsSrc.matchAll(/^\s*export\s+type\s+([A-Za-z_]\w*)\b/gm)) types.add(m[1]);
  // export interface Foo { ... }
  for (const m of tsSrc.matchAll(/^\s*export\s+interface\s+([A-Za-z_]\w*)\b/gm)) types.add(m[1]);
  // export class Foo { ... }
  for (const m of tsSrc.matchAll(/^\s*export\s+class\s+([A-Za-z_]\w*)\b/gm)) values.add(m[1]);
  // export function foo(...) { ... }
  for (const m of tsSrc.matchAll(/^\s*export\s+function\s+([A-Za-z_]\w*)\b/gm)) values.add(m[1]);
  // export const foo = ...
  for (const m of tsSrc.matchAll(/^\s*export\s+const\s+([A-Za-z_]\w*)\b/gm)) values.add(m[1]);
  // export enum Foo { ... }
  for (const m of tsSrc.matchAll(/^\s*export\s+enum\s+([A-Za-z_]\w*)\b/gm)) values.add(m[1]);

  // Also handle "export { a, b as c }" lines (but exclude "from" re-exports).
  for (const m of tsSrc.matchAll(/^\s*export\s*\{\s*([^}]+)\s*\}\s*;\s*$/gm)) {
    const inside = m[1];
    const parts = inside.split(",").map(s => s.trim()).filter(Boolean);
    for (const p of parts) {
      // "a as b" -> take exported name on RHS if present, else LHS
      const as = p.split(/\s+as\s+/i).map(x => x.trim()).filter(Boolean);
      const exportedName = (as[1] || as[0] || "").replace(/[^A-Za-z0-9_]/g, "");
      if (exportedName) values.add(exportedName);
    }
  }

  // Types may also be value-exported in TS (interfaces/types are erased),
  // but we keep them in the type channel only to avoid TS duplicate symbol conflicts.
  return {
    types: [...types].sort(),
    values: [...values].sort(),
  };
}

const perFile = FILES.map(f => ({ rel: f.rel, ...extractExports(read(f.ts)) }));

// Compose canonical barrel WITHOUT export *.
let out = `// Frozen contracts barrel (no star re-exports).\n// Generated by scripts/patch_sentinel_core_contracts_barrel_no_star_v1.mjs\n\n`;

for (const f of perFile) {
  if (f.values.length) out += `export { ${f.values.join(", ")} } from "${f.rel}";\n`;
  if (f.types.length) out += `export type { ${f.types.join(", ")} } from "${f.rel}";\n`;
}

out = out.trimEnd() + "\n";

// Idempotent write: only touch if changed.
const prev = exists(BARREL) ? read(BARREL) : "";
if (prev !== out) {
  write(BARREL, out);
}

console.log("OK: sentinel-core contracts/index.ts canonicalized (no export *).");

// Gates: workspace + root (must end green)
run("npm -w @chc/sentinel-core run build");
run("npm test");
run("npm run build");
